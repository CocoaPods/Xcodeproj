module Xcodeproj
  class Project

    # This is the namespace in which all the classes that wrap the objects in
    # a Xcode project reside.
    #
    # The base class from which all classes inherit is AbstractObject.
    #
    # If you need to deal with these classes directly, it's possible to include
    # this namespace into yours, making it unnecessary to prefix them with
    # Xcodeproj::Project::Object.
    #
    # @example
    #   class SourceFileSorter
    #     include Xcodeproj::Project::Object
    #   end
    #
    module Object

      # @abstract
      #
      # This is the base class of all object types that can exist in a Xcode
      # project. As such it provides common behavior, but you can only use
      # instances of subclasses of AbstractObject, because this class does
      # not exist in actual Xcode projects.
      #
      # Almost all the methods implemented by this class are not expected to be
      # used by {Xcodeproj} clients.
      #
      # Subclasses should clearly identify which methods reflect the xcodeproj
      # document model and which methods are offered as convenience. Object
      # lists always reppresent a relationship to many of the model while
      # simple arrays reppresent dynamically generated values offered a
      # convenience for clients.
      #
      class AbstractObject

        # @return [String] the isa of the class.
        #
        def self.isa
          @isa ||= name.split('::').last
        end

        # @return [String] the object's class name.
        #
        attr_reader :isa

        # It is not recommended to instantiate objects through this
        # constructor. To create objects manually is easier to use
        # the {Project#new}. Otherwise, it is possible to use the convenience
        # methods offered by {Xcodeproj} which take care of configuring the
        # objects for common usage cases.
        #
        # @param [Project] project
        #   the project that will host the object.
        #
        # @param [String] uuid
        #   the UUID of the new object.
        #
        def initialize(project, uuid)
          @project, @uuid = project, uuid
          @isa = self.class.isa
          @referrers = []
          raise "[Xcodeproj] Attempt to initialize an abstract class." unless @isa.match(/^(PBX|XC)/)
        end

        # Initializes the object with the default values of simple attributes.
        #
        # This method is called by the {Project#new} and is not performed on
        # initialization to prevet adding defaults to objects generated by a
        # plist.
        #
        # @return [void]
        #
        def initialize_defaults
          simple_attributes.each { |a| a.set_default(self) }
        end

        # @return [String] the object universally unique identifier.
        #
        attr_reader :uuid

        # @return [Project] the project that owns the object.
        #
        attr_reader :project

        # Removes the object from the project by asking to its referrers to
        # remove the reference to it.
        #
        # @note The root object is owned by the project and should not be
        #       manipulated with this method.
        #
        # @return [void]
        #
        def remove_from_project
          @project.objects_by_uuid.delete(uuid)
          @referrers.each { |referrer| referrer.remove_reference(self) }
          raise "[Xcodeproj] BUG: #{self} should have no referrers instead the following objects are still referencing it #{referrers}" unless referrers.count == 0
        end

        # Returns the value of the name attribute or returns a generic name for
        # the object.
        #
        # @note Not all concrete classes implement the name attribute and this
        #       method prevents from overriding it in plist.
        #
        # @return [String] a name for the object.
        #
        def display_name
          result = name if respond_to?(:name)
          result || isa.gsub(/^(PBX|XC)/, '')
        end

        # @!group Reference counting

        # @return [Array<ObjectList>] The list of the objects that have a
        #   reference to this object.
        #
        attr_reader :referrers

        # Informs the object that another object is referencing it. If the
        # object had no previous references it is added to the project UUIDs
        # hash.
        #
        # @return [void]
        #
        def add_referrer(referrer)
          @referrers << referrer
          if @referrers.count >= 1
            @project.objects_by_uuid[uuid] = self
          end
        end

        # Informs the object that another object stopped referencing it. If the
        # object has no other references it is removed form project UUIDs hash
        # because it is unreachable.
        #
        # @return [void]
        #
        def remove_referrer(referrer)
          @referrers.delete(referrer)
          if @referrers.count == 0
            @project.objects_by_uuid.delete(uuid)
          end
        end

        # Removes all the references to a given object.
        #
        # @return [void]
        #
        def remove_reference(object)
          to_one_attributes.each do |attrb|
            value = attFb.get_value(self)
            attrb.set_value(self, nil) if value.equal?(object)
          end

          to_many_attributes.each do |attrb|
            list = attrb.get_value(self)
            list.delete(object)
          end
        end

        # @!group Plist related methods

        # Configures the object with the objects hash from a plist.
        #
        # **Implementation detail**: it is important that the attributes for a
        # given concrete class are unique because the value is removed from the
        # array at each iteration and duplicate would result in nil values.
        #
        # @return [void]
        #
        def configure_with_plist(objects_by_uuid_plist)
          object_plist = objects_by_uuid_plist[uuid].dup

          raise "[Xcodeproj] Attempt to initialize `#{isa}` from plist with different isa `#{object_plist}`" unless object_plist['isa'] == isa
          object_plist.delete('isa')

          simple_attributes.each do |attrb|
            attrb.set_value(self, object_plist[attrb.plist_name])
            object_plist.delete(attrb.plist_name)
          end

          to_one_attributes.each do |attrb|
            ref_uuid = object_plist[attrb.plist_name]
            if ref_uuid
              ref = project.objects_by_uuid[ref_uuid] || project.new_from_plist(ref_uuid, objects_by_uuid_plist)
              attrb.set_value(self, ref)
            end
            object_plist.delete(attrb.plist_name)
          end

          to_many_attributes.each do |attrb|
            ref_uuids = object_plist[attrb.plist_name] || []
            list = attrb.get_value(self)
            ref_uuids.each do |ref_uuid|
              ref = project.objects_by_uuid[ref_uuid] || project.new_from_plist(ref_uuid, objects_by_uuid_plist)
              list << ref
            end
            object_plist.delete(attrb.plist_name)
          end

          raise "Xcodeproj doesn't know about the following attributes #{object_plist} for the '#{isa}' isa." unless object_plist.empty?
        end

        # @note the key for simple and to_one attributes usually appears only
        #       if there is a value. To many keys always appear with an empty
        #       array.
        #
        def to_plist
          plist = {}
          plist['isa'] = isa

          simple_attributes.each do |attrb|
            value = attrb.get_value(self)
            plist[attrb.plist_name] = value if value
          end

          to_one_attributes.each do |attrb|
            obj = attrb.get_value(self)
            plist[attrb.plist_name] = obj.uuid if obj
          end

          to_many_attributes.each do |attrb|
            list = attrb.get_value(self)
            plist[attrb.plist_name] = list.uuids
          end

          plist
        end
        alias :to_hash :to_plist

        # !@group Object methods

        def ==(other)
          other.is_a?(AbstractObject) && self.to_plist == other.to_plist
        end

        def <=>(other)
          self.uuid <=> other.uuid
        end

        def inspect
          s = "#<UUID: `#{uuid}', isa: `#{isa}'>"
          s << ", name: `#{name}'" if respond_to?(:name) && name
          s
        end
      end
    end
  end
end

require 'xcodeproj/project/object_attributes'
require 'xcodeproj/project/object_list'

# Required because some classes have cyclical references to each other.
Xcodeproj::Constants::KNOWN_ISAS.each do |superclass, isas|
  superklass = Xcodeproj::Project::Object.const_get(superclass)
  isas.each do |isa|
    c = Class.new(superklass)
    Xcodeproj::Project::Object.const_set(isa, c)
  end
end

# Now load the concrete subclasses.
require 'xcodeproj/project/object/build_configuration'
require 'xcodeproj/project/object/build_file'
require 'xcodeproj/project/object/build_phase'
require 'xcodeproj/project/object/build_rule'
require 'xcodeproj/project/object/configuration_list'
require 'xcodeproj/project/object/container_item_proxy'
require 'xcodeproj/project/object/file_reference'
require 'xcodeproj/project/object/group'
require 'xcodeproj/project/object/native_target'
require 'xcodeproj/project/object/root_object'
require 'xcodeproj/project/object/target_dependency'

