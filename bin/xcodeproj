#!/usr/bin/env ruby
# encoding: utf-8

if $0 == __FILE__
  $:.unshift File.expand_path('../../ext', __FILE__)
  $:.unshift File.expand_path('../../lib', __FILE__)
end

require 'xcodeproj'

require 'optparse'
$options = {}
$option_parser = OptionParser.new do |opts|
  opts.banner  = "Usage: xcodeproj [command] [options]"
  opts.separator ""
  opts.separator "Commands:"
  opts.separator ""
  opts.separator "  show                                  Shows a tree reppresentation."
  opts.separator "  targets-diff [target 1] [target 2]    Shows the difference between two targets. (Only build source files atm.)"
  opts.separator ""

  opts.separator "Options:"
  opts.separator ""

  opts.on('--project PATH', "The Xcode project document to use.") do |xcodeproj|
    $options[:xcodeproj] = xcodeproj
  end

  opts.on("--version", "Show xcodeproj version.") do |v|
    puts Xcodeproj::VERSION
    exit
  end
end
$option_parser.parse!


def invalid_command(msg = nil)
  if msg
    puts msg
    puts
  end
  puts $option_parser
  exit 1
end


def xcodeproj
  unless xcodeproj = $options[:xcodeproj]
    projects = Dir.glob('*.xcodeproj')
    if projects.size == 1
      xcodeproj = projects.first
    elsif projects.size > 1
      invalid_command('There are more than one Xcode project documents in the current working directory. Please specify which to use.')
    else
      invalid_command('No Xcode project document found in the current working directory. Please specify which to use.')
    end
  end
  File.expand_path(xcodeproj)
end


class Xcodeproj::Project::Object::PBXGroup
  # attributes :path
end
class Xcodeproj::Project::Object::PBXFileReference
  alias_method :_path, :path
  def path
    # TODO somethings not working right, I'm seeing the dir being prepended twice with ZipKit
    # if (sourceTree == '<group>') && dir = group.path
    #   File.join(dir, _path)
    # else
    #   _path
    # end
  end
end
def target_source_files(project, target_name)
  project.targets.object_named(target_name).source_build_phases.map do |source_build_phase|
    source_build_phase.files.map { |buildFile| buildFile.file.path }
  end.flatten.sort
end


case cmd = ARGV.shift
when 'targets-diff'
  target1, target2 = ARGV.first(2)
  if target1 && target2
    project = Xcodeproj::Project.new(xcodeproj)
    target1_files = target_source_files(project, target1)
    target2_files = target_source_files(project, target2)

    diff = target1_files - target2_files
    puts "Files in `#{target1}' which are not present in `#{target2}':\n* #{diff.join("\n* ")}\n\n" unless diff.empty?

    diff = target2_files - target1_files
    puts "Files in `#{target2}' which are not present in `#{target1}':\n* #{diff.join("\n* ")}\n\n" unless diff.empty?
  else
    invalid_command("Needs the names of the two targets to diff.")
  end

when 'show'
  project = Xcodeproj::Project.new(xcodeproj)
  def inspec_obj(obj, level = 0)
    if obj.respond_to?(:children) && !obj.children.empty?
      display(obj, level) + "\n" + (obj.children.map { |child| inspec_obj(child, level + 1) } * "\n")
    else
      display(obj, level)
    end
  end

  def display(obj, indentation, show_isa = true, show_uuid = false)
    name = case obj
    when Xcodeproj::Project::Object::PBXFileReference
      obj.name
    when Xcodeproj::Project::Object::PBXGroup
      obj.name
    when Xcodeproj::Project::Object::PBXBuildFile
      obj.file.name
    when Xcodeproj::Project::Object::PBXCopyFilesBuildPhase
      obj.dst_path
    when Xcodeproj::Project::Object::PBXBuildPhase
      "[ #{obj.files.count} #{obj.files.count == 1 ? 'file' : 'files'} ]"
    when Xcodeproj::Project::Object::PBXNativeTarget
      "#{obj.product_name} - #{obj.product_type.gsub('com.apple.product-type.','')}"
    when Xcodeproj::Project::Object::PBXProject
      "[ targets: #{obj.targets.map(&:name) * ", "} ]"
    when Xcodeproj::Project::Object::XCBuildConfiguration
      "#{obj.name} - #{obj.build_settings.count} settings"
    when Xcodeproj::Project::Object::XCConfigurationList
      obj.build_configurations.map(&:name) * ", "
    else
      'no'
    end
    indented_name = "  " * indentation + name
    r =  indented_name
    r =  r.ljust(40)                 if show_uuid || show_isa
    r << obj.uuid                    if show_uuid
    r << "  " << obj.isa             if show_isa
    r
  end

  objects_by_isa = {}
  project.objects.each do |obj|
    objects_by_isa[obj.isa] = [] unless objects_by_isa[obj.isa]
    objects_by_isa[obj.isa] << obj
  end

  s_objects = ''
  objects_by_isa.sort.each do |isa, objs|
    s_objects << "\e[1;32m#{isa}:\e[0m\n"
    s_objects << objs.sort_by(&:name).map {|obj| display(obj, 1, false)} * "\n" + "\n\n"
  end

  s_root_object = project.main_group.children.map do |child|
    inspec_obj(child)
  end * "\n"

  puts "\n\e[1;33mOBJECTS:\e[0m\n\n"
  puts "#{s_objects}"
  puts "\n\e[1;33mMAIN GROUP:\e[0m\n\n"
  puts "#{s_root_object}\n\n"
else
  invalid_command(cmd.nil? ? nil : "Unknown command: #{cmd}")
end
